---
title: "Project 2: 2022 World Cup Simulation"
output:
  html_document:
    theme: flatly          # clean and modern look
    df_print: paged        # pretty paginated tables
    code_folding: show 
    css: style.css
---

# 2022 World Cup Simulation
The goal of this project is to simulate the 2022 FIFA World Cup using historical match results. We employ a Bradley-Terry Model to estimate team strengths based on prior international matches and incorporate goal differentials to better capture team performance. Using these estimates, we simulate group-stage outcomes, rank teams within each group, and identify the top qualifiers for the knockout rounds. This approach provides a probabilistic assessment of team performance, highlighting likely group winners and potential upsets. As a way of honoring the competitive and random nature of the World Cup, our project will return a single winner each time it is ran. Hopefully this will demonstrate the randomness that the real tournament has grown so renowned for. 

```{r load-libraries-and-packages, message=FALSE}
#install.packages("BradleyTerry2")
library(tidyverse)
library(dplyr)
library(lubridate)
library(BradleyTerry2)
library(ggplot2)
library(knitr)

results = read_csv("results.csv")
```

```{r}
teams_2022 <- c(
  "Qatar", "Ecuador", "Senegal", "Netherlands",
  "England", "Iran", "United States", "Wales",
  "Argentina", "Saudi Arabia", "Mexico", "Poland",
  "France", "Australia", "Denmark", "Tunisia",
  "Spain", "Costa Rica", "Germany", "Japan",
  "Belgium", "Canada", "Morocco", "Croatia",
  "Brazil", "Serbia", "Switzerland", "Cameroon",
  "Portugal", "Ghana", "Uruguay", "South Korea"
)
```

## Clean and filter data
Our analysis uses international match results from 2016 through November 2022. We filtered the dataset to include only matches between teams that qualified for the 2022 World Cup. Each match record contains the home and away teams, scores, and match dates. From these data, we computed wins, losses, and draws for each team, forming the basis for our Bradley-Terry model and subsequent simulations.

```{r clean-and-filter-data}
results_filtered = results %>%
  mutate(date = as.Date(date)) %>%            
  filter(date >= as.Date("2016-01-01") & date < as.Date("2022-11-20")) %>%
  filter(home_team %in% teams_2022 & away_team %in% teams_2022) %>% 
  #filter(tournament != "Friendly") %>% originally wanted to not include friendlies, but decided against this.
  mutate(
    home_win = case_when(
      home_score > away_score ~ 1,
      home_score < away_score ~ 0,
      TRUE ~ NA_real_
    ),
    tie = case_when(
      home_score == away_score ~ 1
    )
  )
kable(head(results_filtered))
```

## Organize to format properly for BTM
After filtering the match results for the 32 World Cup teams, we organized the data into head-to-head pairings. Each row records the number of wins for the home and away teams in their encounters. Missing values are set to zero to ensure all pairings are complete. Teams are converted to factors to allow proper modeling with the Bradley Terry framework. This setup ensures that the model can calculate relative team strengths accurately.

```{r organize-for-BTM-fit}
pair_results <- results_filtered %>%
  group_by(home_team, away_team) %>%
  summarise(
    home_wins = sum(home_win == 1, na.rm = FALSE),
    away_wins = sum(home_win == 0, na.rm = FALSE),
    .groups = "drop"
  )
pair_results[is.na(pair_results)] <- 0

teams <- sort(unique(c(pair_results$home_team, pair_results$away_team)))

pair_results$home_team <- factor(pair_results$home_team, levels = teams)
pair_results$away_team <- factor(pair_results$away_team, levels = teams)
kable(head(pair_results))
```

## Fit BTM
To model the relative strengths of each team, we applied the Bradley-Terry model, which estimates the probability that one team defeats another in a head-to-head matchup by assigning a latent strength parameter to each team. We incorporated goal differentials as covariate to better capture performance differences beyond simple win-loss outcomes. Additionally, we included a tie parameter to account for draws, which are common in group-stage matches. This enhanced model allows us to simulate match outcomes with realistic probabilities for wins, losses, and ties.

```{r fit-model}
fit <- BTm(
  cbind(home_wins, away_wins),
  player1 = home_team,
  player2 = away_team,
  data = pair_results,
  refcat = "Iran"
)

abilities = BTabilities(fit)

abilities_df <- as.data.frame(abilities) %>%
  rownames_to_column("team") %>%
  arrange(desc(ability))

kable(head(abilities_df))
```

### Plot showing abilities of each team
The abilities plot shows the latent strength of each team as estimated by the Bradley-Terry models. Teams with higher values are expected to win more often in matchups. The fill color indicates standard error, which reflects uncertainty: teams with limited match data have higher standard errors. This visualization provides a quick comparison of team quality heading into the tournament.

```{r}
ggplot(abilities_df, aes(
  x = reorder(team, ability),
  y = ability,
  fill = s.e.   # map fill color to standard error, shows lack of data for Australia
)) +
  geom_col() +
  coord_flip() +
  scale_fill_gradient(low = "steelblue", high = "firebrick", name = "Standard Error") +
  labs(
    title = "Estimated Team Strengths (Bradley–Terry Model)",
    x = "Team",
    y = "Latent Strength Parameter (Ability)"
  ) +
  theme_minimal(base_size = 13)
```

## Goal differential dataframe to use in our match simulation function
We calculated each team’s goal differential (goals scores minus goals conceded) to capture performance beyond simple win-loss records. The average goal differential per game provides additional context for simulating realistic match outcomes, particularly for tie-breaking in group stages. This metric complements the Bradley-Terry ability estimates by accounting for offensive and defensive strengths. The extremely negative value for Australia is most likely from a lack of data

```{r}
goal_diff = results_filtered %>% # set up goal differential for each team to use in match simulation
  select(team = home_team, goals_for = home_score, goals_against = away_score) %>% 
  bind_rows(
    results_filtered %>% 
      select(team = away_team, goals_for = away_score, goals_against = home_score)
  ) %>% 
  group_by(team) %>% 
  summarise(
    goals_for = sum(goals_for, na.rm = TRUE),
    goals_against = sum(goals_against, na.rm = TRUE),
    goal_diff = goals_for-goals_against,
    games = n(),
    avg_goal_diff = goal_diff/games
  ) %>% 
  ungroup() %>% 
  arrange(desc(avg_goal_diff))
kable(head(goal_diff))
```

## Simulating matches for group stage. Needed to include a parameter for ties. 
Group-stage matches can result in a win, loss, or a draw. To model this, the get_prob_ties function calculates the probabilities of each outcome using team abilities and goal differentials. The tie parameter accounts for the likelihood of draws, which are common in the group stage. These probabilities form the basis for simulating match results probabilistically.


```{r}
get_prob_ties = function(teamA, teamB, abilities_df, goal_diff, beta = .1, nu = 1) {
  lambdaA = abilities_df$ability[abilities_df$team == teamA]
  lambdaB = abilities_df$ability[abilities_df$team == teamB]
  
  goal_lambda_A = goal_diff$avg_goal_diff[goal_diff$team==teamA]
  goal_lambda_B = goal_diff$avg_goal_diff[goal_diff$team==teamB]
  difference = as.numeric(goal_lambda_A-goal_lambda_B)

  
  lambdaA_adj = lambdaA + beta * (difference)
  
  expA = exp(lambdaA_adj)
  expB = exp(lambdaB)
  nu_adj = nu*abs(lambdaA-lambdaB)
  tie_term = nu_adj * sqrt(expA * expB)

  p_winA = expA / (expA + expB + tie_term)
  p_winB = expB / (expA + expB + tie_term)
  p_tie  = tie_term / (expA + expB + tie_term)
  
  return(c(p_winA = p_winA, p_tie = p_tie, p_winB = p_winB))
}

kable(get_prob_ties(teamA = "Argentina", teamB = "Mexico", abilities_df, goal_diff, beta=0.1, nu=1))
```

### Make each group. This will help us make matrices for each group. 
The 32 World Cup teams are organized into their official groups (A-H). Grouping is essential for building probability matrices and simulating the group-stage matches. Each group contains four teams, allowing us to systematically generate all intra-group matchups.

```{r}
groups_df <- tibble(
  group = c(
    rep("A", 4), rep("B", 4), rep("C", 4), rep("D", 4),
    rep("E", 4), rep("F", 4), rep("G", 4), rep("H", 4)
  ),
  team = c(
    "Qatar", "Ecuador", "Senegal", "Netherlands",
    "England", "Iran", "United States", "Wales",
    "Argentina", "Saudi Arabia", "Mexico", "Poland",
    "France", "Australia", "Denmark", "Tunisia",
    "Spain", "Costa Rica", "Germany", "Japan",
    "Belgium", "Canada", "Morocco", "Croatia",
    "Brazil", "Serbia", "Switzerland", "Cameroon",
    "Portugal", "Ghana", "Uruguay", "South Korea"
  )
)
kable(head(groups_df))
```

## Function simulating matches including ties.
The simulate_match_tie function uses the probabilities from get_prob_ties to simulate each group-stage match. It randomly selects an outcome based on win, loss, or tie probabilities and assigns points and goal differences according to FIFA rules. Goal margins are randomized to reflect natural variability, which is useful for tie-breaking in standings.


```{r}
simulate_match_tie <- function(teamA, teamB) {
    probs <- get_prob_ties(teamA, teamB, abilities_df, goal_diff, beta=.1, nu=1)
    outcome <- sample(c("A_win", "Tie", "B_win"), size = 1, prob = probs[c("p_winA", "p_tie", "p_winB")])
    
    goal_margin <- round(rnorm(1, mean = 1.5, sd = 0.8), ) # we gave goal differential a random distribution to account for tie breakers
    if (goal_margin < 1) goal_margin <- 1
    
    if (outcome == "A_win") {
      gdA <- goal_margin
      gdB <- -goal_margin
      pointsA <- 3; pointsB <- 0
    } else if (outcome == "B_win") {
      gdA <- -goal_margin
      gdB <- goal_margin
      pointsA <- 0; pointsB <- 3
    } else {  # Tie
      gdA <- 0; gdB <- 0
      pointsA <- 1; pointsB <- 1
    }
    
    tibble(
      home_team = teamA,
      away_team = teamB,
      outcome = outcome,
      points_home = pointsA,
      points_away = pointsB,
      gd_home = gdA,
      gd_away = gdB
    )
}

kable(simulate_match_tie("United States", "England"))
```
## Build matrices representing each group
To simulate all group-stage matches efficiently, we create probability matrices for each group. P_win stores the probability of each team beating another, while P_tie stores the probability of a draw. These matrices enable rapid lookup of match probabilities during simulations.


```{r}
build_group_matrices <- function(groups_df, abilities_df, goal_diff) {
  group_matrices <- list()
  
  for (g in unique(groups_df$group)) {
    teams <- groups_df$team[groups_df$group == g]
    n <- length(teams)
    
    # Initialize matrices
    P_win <- matrix(0, n, n, dimnames = list(teams, teams))
    P_tie <- matrix(0, n, n, dimnames = list(teams, teams))
    
    # Fill in probabilities
    for (i in seq_len(n)) {
      for (j in seq_len(n)) {
        if (i == j) next
        probs <- get_prob_ties(teams[i], teams[j], abilities_df, goal_diff)
        P_win[i, j] <- probs["p_winA"]
        P_tie[i, j] <- probs["p_tie"]
      }
    }
    
    group_matrices[[g]] <- list(P_win = P_win, P_tie = P_tie)
  }
  
  return(group_matrices)
}
group_matrices = build_group_matrices(groups_df, abilities_df, goal_diff)
kable(group_matrices[2])
```
## Simulate matches in group stage and create standings.
Using the estimated team strengths, we simulated the group stage of the World Cup. For each group, every team played a single match against the other three teams. Outcomes were determined probabilistically based on the team-specific win and tie probabilities derived from the Bradley-Terry model. Points were allocated according to standard FIFA rules: 3 points for a win, 1 point for a draw, and 0 points for a loss. Goal differences were updated for each match to break ties in group standings.

The simulated_group_from_matrix function handles these simulations for individual groups. It iterates over each pair of teams, samples match outcomes based on the calculated probabilities, and updates the standings with points, wins, draws, losses, and goal differentials. The simulate_all_groups function repeats this process for all groups, returning a complete table of group-stage standings.



```{r}
simulate_group_from_matrix <- function(group_name, group_probs) {
  
  P_win <- group_probs[[group_name]]$P_win
  P_tie <- group_probs[[group_name]]$P_tie
  teams <- rownames(P_win)
  n <- length(teams)
  
  # Initialize standings
  standings <- data.frame(
    team = teams,
    points = 0,
    goal_diff = 0,
    wins = 0,
    draws = 0,
    losses = 0,
    stringsAsFactors = FALSE
  )
  
  # Simulate matches
  for (i in 1:(n - 1)) {
    for (j in (i + 1):n) {
      teamA <- teams[i]
      teamB <- teams[j]
      
      pA <- P_win[i, j]
      pB <- P_win[j, i]
      pT <- P_tie[i, j]
      
      # Defensive normalization (for safety)
      probs <- c(pA, pB, pT)
      if (any(is.na(probs)) || sum(probs) == 0) probs <- c(1/3, 1/3, 1/3)
      probs <- probs / sum(probs)
      
      outcome <- sample(c("A", "B", "T"), size = 1, prob = probs)
      
      if (outcome == "A") {
        standings$points[i] <- standings$points[i] + 3
        standings$wins[i] <- standings$wins[i] + 1
        standings$losses[j] <- standings$losses[j] + 1
        standings$goal_diff[i] <- standings$goal_diff[i] + 1
        standings$goal_diff[j] <- standings$goal_diff[j] - 1
      } else if (outcome == "B") {
        standings$points[j] <- standings$points[j] + 3
        standings$wins[j] <- standings$wins[j] + 1
        standings$losses[i] <- standings$losses[i] + 1
        standings$goal_diff[j] <- standings$goal_diff[j] + 1
        standings$goal_diff[i] <- standings$goal_diff[i] - 1
      } else { # Tie
        standings$points[i] <- standings$points[i] + 1
        standings$points[j] <- standings$points[j] + 1
        standings$draws[i] <- standings$draws[i] + 1
        standings$draws[j] <- standings$draws[j] + 1
      }
    }
  }
  
  standings$group <- group_name
  
  # Order by points, goal diff, wins
  standings <- standings %>%
    arrange(desc(points), desc(goal_diff), desc(wins))
  
  return(standings)
}

simulate_all_groups <- function(group_probs) {
  groups <- names(group_probs)
  all_standings <- lapply(groups, simulate_group_from_matrix, group_probs = group_probs)
  standings_df <- bind_rows(all_standings)
  return(standings_df)
}
```
## Extract qualifiers from top 2 teams in each group.
The simulated group-stage standings are shown in the table below. Teams are ranked first by points, then by goal differential, and finally by total wins. This ranking reflects the expected performance of each team based on historical match data and the model’s probabilistic estimates. The top two teams from each group are identified as qualifying for the knockout rounds.


```{r}

group_standings <- simulate_all_groups(group_matrices)

qualifiers = group_standings %>% 
  group_by(group) %>% 
  arrange(desc(points)) %>% 
  slice(1:2) %>% 
  ungroup() %>% 
  mutate(seed = ifelse(row_number() %% 2==1, 1, 2)) %>% 
  select(group, team, seed)
kable(qualifiers)
```

## Simulates a match winner without ties for knockout round.
In the knockout rounds, matches cannot end in a tie. The simulate_match_winner function selects a winner based on adjusted abilities and goal differentials. This function is used for all knockout rounds, ensuring that each match produces a decisive winner.

```{r}
simulate_match_winner = function(teamA, teamB, abilities = abilities_df, beta = 0.1) {
  lambdaA = abilities_df$ability[abilities_df$team == teamA]
  lambdaB = abilities_df$ability[abilities_df$team == teamB]
  
  goal_lambda_A = goal_diff$avg_goal_diff[goal_diff$team==teamA]
  goal_lambda_B = goal_diff$avg_goal_diff[goal_diff$team==teamB]
  difference = as.numeric(goal_lambda_A-goal_lambda_B)

  
  lambdaA_adj = lambdaA + beta * (difference) # Here we use goal differential as a covariate and weight it with our predetermined beta value of 0.1. Higher beta would weigh goal differential heavier.
  
  expA = exp(lambdaA_adj)
  expB = exp(lambdaB)

  p_winA = expA / (expA + expB)
  p_winB = expB / (expA + expB)
  
  winner = sample(c(teamA, teamB), size = 1, prob = c(p_winA, p_winB))


  return(winner)
  }
simulate_match_winner(teamA = "United States", teamB = "England", abilities_df) #example output
```
## Round of 16 matches
Round of 16 matchups pair group winners against runners up from other groups, following FIFA’s official bracket rules. Each match is simulated simulate_match_winner. Winners advance to the quarterfinals, while losers are eliminated. This stage reflects the first round where no draws are allowed.

```{r warning=FALSE}
r16_matchups <- tribble(
  ~match, ~team1_group, ~team1_seed, ~team2_group, ~team2_seed,
   1, "A", 1, "B", 2,
   2, "C", 1, "D", 2,
   3, "E", 1, "F", 2,
   4, "G", 1, "H", 2,
   5, "B", 1, "A", 2,
   6, "D", 1, "C", 2,
   7, "F", 1, "E", 2,
   8, "H", 1, "G", 2
)

# Join to get team names based on group and seed and setup the bracket based on FIFA seedings
r16 <- r16_matchups %>%
  left_join(qualifiers, by = c("team1_group" = "group", "team1_seed" = "seed")) %>%
  rename(team1 = team) %>%
  left_join(qualifiers, by = c("team2_group" = "group", "team2_seed" = "seed")) %>%
  rename(team2 = team) %>%
  select(match, team1_group, team1_seed, team1, team2_group, team2_seed, team2)

```

```{r warning=FALSE}
r16 <- r16 %>%
  mutate(winner = mapply(simulate_match_winner, team1, team2, abilities_df))
kable(r16)
```

## Quarterfinal matches
The quarterfinals feature the winners of the Round of 16. Each matchup is simulated simulated probabilistically, with the victor advancing to the semifinals. This stage begins to highlight potential strong performers and showcases possible tournament upset.

```{r}
qf <- tibble(
  match = 1:4,
  team1 = c(r16$winner[1], r16$winner[3], r16$winner[5], r16$winner[7]),
  team2 = c(r16$winner[2], r16$winner[4], r16$winner[6], r16$winner[8])
)

qf <- qf %>%
  mutate(winner = mapply(simulate_match_winner, team1, team2))
kable(qf)
```
## Semifinal matches
Again, we took the winners of the quarterfinals and matched them up against each other to determine the finalists.

```{r}
sf <- tibble(
  match = 1:2,
  team1 = c(qf$winner[1], qf$winner[3]),
  team2 = c(qf$winner[2], qf$winner[4])
)

sf <- sf %>%
  mutate(winner = mapply(simulate_match_winner, team1, team2))
kable(sf)
```
## Finals
This is where a champion is crowned!

```{r}
final <- tibble(
  match = 1,
  team1 = sf$winner[1],
  team2 = sf$winner[2]
)

final <- final %>%
  mutate(winner = mapply(simulate_match_winner, team1, team2))

champion <- final$winner
cat("2022 World Cup Champion Simulation Winner:", champion, "\n")
```

## Conclusion
While our model does a good job estimating the strength of teams in the world cup, there are certainly shortcomings that may slightly stray our results away from reality. For example, our data only draws from matches between the teams in the world cup, which severely limits the scope of the data. A different model that would include those matches might yield better results. Furthermore, there are many factors that may affect the outcome, such as weather, attendance levels from fans, and time of day. Adding covariates for these factors may yield different results as well. Other interesting directions to further explore would be simulating the tournament thousands of times to see the probabilities of each team advancing and possible winning. 